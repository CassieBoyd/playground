<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title></title>
  <link rel="stylesheet" href="../base.css">
</head>

<body>
    <input type="text" name="first" value="Cassie">
  <script>
      const age = 90;
      // Objects have property/value pairs aka key/value pairs
      // Properties on objects can have names that include things like spaces or dashes but the property name must be in quotes. Probably easier to just stick to variable naming conventions.
    const person = {
        name: "Cassie",
        age: age, //This line could be just "age," since the key and value names match
        clothing: {
            shirt: "black",
            pants: "grey",
        },
        cat: "Peach", // Trailing comma or comma dangle. Even though this is the last property, go ahead and put the comma after it to help out the next person who may be adding another property.

        // sayHello is a method on the person object
        sayHello: function(greeting = "Hi") {
            return `${greeting}, ${this.name}`
        },

        // Can't use "this" keyword when using fat arrow functions
        sneeze: () => {
            console.log("Chew");
        }
    };

    person.job = "Yes, please";
    person.age = 80;

    // Pass object to Object.freeze if you want to prevent it from being updated.
    const cassieFrozen = Object.freeze(person);
    console.log(person)

    console.log("Dot:",person.age);
    
    //const propertyToCheck = prompt("What do you want to check?");
    //console.log("Bracket:",person[propertyToCheck]);
    //console.log("PropToCheck: ",propertyToCheck);

    const nameInput = document.querySelector('[name="first"]');
    // Check whether nameInput exists, if so assign it to .value, if not log an empty string
    const name = nameInput ? nameInput.value : "";
    console.log("name input:", name);
    
    console.log(person);
    console.log(delete person.name);  
    console.log(person);

    console.clear();

    //------------------Lesson 41- Object Reference vs Values--------------------
    let name1 = "Cassie";
    let name2 = "Cassie";
    console.log(name1 === name2);

    name1 = "Ken";
    console.log(name1 === name2);

    // Update name1 to equal the value of name2
    name1 = name2;
    console.log(name1 === name2);
    name2 = name1;

    console.log(name2);
    name2 = "Cassandra";
    console.log(name2);

    const person1 = {
        first: "Cassie",
        last: "Boyd",
    };

    const person2 = {
        first: "Cassie",
        last: "Boyd",
    };

    console.log("Persons 1 & 2 equal?",person1 === person2);

    //const person3 = person1;
    //console.log(person3.first);
    //person3.first = "Peach";
    //console.log("person3", person3.first);
    console.log("person1",person1.first); // Will be Peach instead of Cassie because when objects or arrays are pointed to (put in a variable) by reference (line 90) it doesn't actually create a new object. So, when I updated person3 to be named Peach, I was actually updating person1 because person3 never existed as an object. Same principals apply for arrays, maps and sets. 

    const person4 = { ...person1 }; // Spread operator used to copy objects
    person4.first = "Ruth";
    console.log(person4.first);
    console.log(person1.first);


  </script>
</body>

</html>