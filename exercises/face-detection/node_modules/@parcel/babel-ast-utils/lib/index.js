"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parse = parse;
exports.generate = generate;
exports.convertBabelLoc = convertBabelLoc;
Object.defineProperty(exports, "babelErrorEnhancer", {
  enumerable: true,
  get: function () {
    return _babelErrorUtils.babelErrorEnhancer;
  }
});

var _path = _interopRequireDefault(require("path"));

var _generator = _interopRequireDefault(require("@babel/generator"));

var _parser = require("@babel/parser");

var _sourceMap = _interopRequireDefault(require("@parcel/source-map"));

var _utils = require("@parcel/utils");

var _babelErrorUtils = require("./babelErrorUtils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function parse({
  asset,
  code,
  options
}) {
  try {
    return {
      type: 'babel',
      version: '7.0.0',
      program: (0, _parser.parse)(code, {
        sourceFilename: (0, _utils.relativeUrl)(options.projectRoot, asset.filePath),
        allowReturnOutsideFunction: true,
        strictMode: false,
        sourceType: 'module',
        plugins: ['exportDefaultFrom', 'exportNamespaceFrom', 'dynamicImport']
      })
    };
  } catch (e) {
    throw await (0, _babelErrorUtils.babelErrorEnhancer)(e, asset);
  }
}

async function generate({
  asset,
  ast,
  options
}) {
  let sourceFileName = (0, _utils.relativeUrl)(options.projectRoot, asset.filePath);
  let generated;

  try {
    generated = (0, _generator.default)(ast.program, {
      sourceMaps: options.sourceMaps,
      sourceFileName: sourceFileName
    });
  } catch (e) {
    throw await (0, _babelErrorUtils.babelErrorEnhancer)(e, asset);
  }

  let map = null;
  let originalSourceMap = await asset.getMap();

  if (generated.rawMappings) {
    map = new _sourceMap.default();
    map.addIndexedMappings(generated.rawMappings);

    if (originalSourceMap) {
      map.extends(originalSourceMap.toBuffer());
    }
  } else {
    map = originalSourceMap;
  }

  return {
    content: generated.code,
    map
  };
}

function convertBabelLoc(loc) {
  if (!loc) return null;
  let {
    filename,
    start,
    end
  } = loc;
  if (filename == null) return null;
  return {
    filePath: _path.default.normalize(filename),
    start: {
      line: start.line,
      column: start.column + 1
    },
    // - Babel's columns are exclusive, ours are inclusive (column - 1)
    // - Babel has 0-based columns, ours are 1-based (column + 1)
    // = +-0
    end: {
      line: end.line,
      column: end.column
    }
  };
}